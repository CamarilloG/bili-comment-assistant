I have analyzed the request. The user wants to use Bilibili's native date selection component when possible, instead of just post-filtering. This is much more efficient as it reduces the number of irrelevant videos loaded.

The user provided HTML snippets for:

1. **Date Picker Trigger**: `.search-date-picker__trigger` (Start/End date).
2. **Quick Filters**: `.search-condition-row` containing buttons like "最近一天" (Last Day), "最近一周" (Last Week), "最近半年" (Last 6 Months).

**Plan:**

1. **Update** **`core/selectors.py`**:

   * Add `FILTER` dictionary to `BilibiliSelectors`.

   * Add selectors for:

     * `time_limit_btn`: Buttons like "最近一天", "最近一周".

     * `date_picker_trigger`: `.search-date-picker__trigger`.

     * `date_picker_panel`: `.search-date-picker` (the popup).

     * `date_picker_confirm`: Button to confirm date range (if any, or clicking outside).

2. **Update** **`core/search.py`**:

   * Add `apply_time_filter(time_filter_config)` method to `SearchManager`.

   * **Logic**:

     * After `page.goto(url)`, wait for the filter row (`.search-condition-row`) to load.

     * If `type == "recent"`:

       * Map "1 day" -> Click "最近一天".

       * Map "7 days" -> Click "最近一周".

       * If custom days (e.g. 3), Bilibili might not support it directly via button. Fallback to **Post-Filtering** or try to set Date Range manually.

       * *Decision*: If it matches a preset (1, 7, 180), click the button. Else, use Date Range picker or fallback to post-filtering.

     * If `type == "range"`:

       * Click `.search-date-picker__trigger`.

       * Wait for panel.

       * *Complexity*: Interacting with a custom JS date picker can be flaky.

       * *Alternative*: Bilibili URL *might* support `&tids_2=...` or similar if we reverse engineer it. But the user explicitly asked to "Priority call Bilibili's own component".

       * *Implementation*:

         * Click trigger.

         * Fill Start Date / End Date inputs (if they are inputs).

         * Or click specific dates in the calendar grid.

         * *Refinement*: The provided HTML shows `.date-trigger.start` and `.date-trigger.end`. These might just be display divs. The actual inputs might be hidden or inside the popup.

         * *Strategy*: Since implementing a full calendar interaction is risky without live debugging, I will prioritize the **Quick Filter Buttons** (Recent 1 Day, 1 Week) as they are standard buttons.

         * For "Date Range", I will try to support it if I can find the inputs. If not, I will log a warning and fallback to Post-Filtering.

3. **Update** **`main.py`**:

   * Call `search_mgr.apply_time_filter(filter_config)` immediately after navigation.

   * If native filter applied successfully, disable/relax the strict post-filtering (or keep it as a double-check).

**Revised Plan Details**:

* **Selectors**:

  * `filter_btn_1day`: `button:has-text("最近一天")`

  * `filter_btn_1week`: `button:has-text("最近一周")`

  * `filter_btn_6months`: `button:has-text("最近半年")`

* **Logic**:

  * In `search_videos`, after `goto`, call `apply_filters`.

  * If `time_range.type == 'recent'`:

    * If value == 1: Click "最近一天".

    * If value == 7: Click "最近一周".

    * Else: Fallback to post-filter.

  * If `time_range.type == 'range'`:

    * Fallback to post-filter (safest for now unless user insists on picker interaction which is complex). *Wait*, user said "Date selection component priority".

    * I'll try to implement it: Click trigger -> Check if inputs appear -> Fill -> Confirm.

**Safe Approach**:
I will implement the **Quick Buttons** first (Recent 1 Day, Week, Half Year) as they cover most use cases and are reliable. For custom ranges, I'll stick to post-filtering for reliability unless I see clear input fields in the selector analysis.

*Correction*: User explicitly said "Date selection component priority".
I will add the selectors for the date picker trigger.
I'll add a method `interact_date_picker(start, end)` which attempts to use the UI.

**Files to Modify**:

* `core/selectors.py`

* `core/search.py`

* `main.py` (to trigger the new filter method)

